<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Simple 8-Ball Demo</title>
    <link rel="stylesheet" href="styles/pool.css">
</head>

<body>
    <div class="game-wrapper">
        <header class="game-header">
            <h1>8-Ball Demo</h1>
            <p>
                Mouse: drag from cue ball to shoot.
                Keyboard mode (press K): ↑/↓ set power 1–14, Space to shoot. Cycle Through K if Space-bar fails.
            </p>
        </header>

        <main class="game-main">
            <canvas id="table" width="900" height="500"></canvas>

            <div class="hud">
                <div class="status">
                    <p id="statusText">Ready – drag from cue ball to shoot.</p>
                </div>

                <div class="power-panel">
                    <div class="power-label">
                        Power: <span id="powerValue">1</span> / 14
                        <span id="modeLabel">(Mouse)</span>
                    </div>
                    <div class="power-bar-outer">
                        <div id="powerBarFill" class="power-bar-fill"></div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        let currentPlayer = 1;         // 1 or 2
        let playerGroup = { 1: null, 2: null }; // 'solid' or 'stripe'
        let playerHits = { 1: 0, 2: 0 };        // how many of their own balls pocketed
        let maxHitsPerPlayer = 5;

        let gameOver = false;

        const canvas = document.getElementById('table');
        const ctx = canvas.getContext('2d');

        const TABLE = {
            x: 60,
            y: 40,
            width: canvas.width - 120,
            height: canvas.height - 80,
            clothColor: '#0b6b3a',
            railColor: '#3a2712'
        };

        const BALL_RADIUS = 10;
        const POCKET_RADIUS = 23;
        const FRICTION = 0.99;
        const MIN_SPEED = 0.01;
        const ROLL_DRAG = 0.0006;  // how quickly speed bleeds off per frame

        // Helper to "pull" balls into pockets when they get close
        const POCKET_ATTRACT_RADIUS = POCKET_RADIUS * 3;  // how far the assist reaches
        const POCKET_ATTRACT_STRENGTH = 0.001;            // how strong the pull is
        const POCKET_ATTRACT_MAX_SPEED = 1;              // only help slower balls



        const MIN_POWER = 1;
        const MAX_POWER = 14;

        const balls = [];
        const pockets = [];

        // Input / HUD state
        let isDragging = false;
        let dragPos = null;
        let hoverPos = null;      // NEW: mouse position even when not dragging

        let ballInHand = false;
        let placingCue = false;

        let useKeyboardPower = false;   // false = mouse, true = keyboard mode
        let currentPower = MIN_POWER;   // 1–14 for both systems

        const powerValueEl = document.getElementById('powerValue');
        const powerBarFillEl = document.getElementById('powerBarFill');
        const modeLabelEl = document.getElementById('modeLabel');

        function makeBall(x, y, color, number, type) {
            return { x, y, vx: 0, vy: 0, color, number, type, inPlay: true };
        }

        function initPockets() {
            pockets.length = 0;
            const { x, y, width, height } = TABLE;
            pockets.push({ x, y });
            pockets.push({ x: x + width / 2, y });
            pockets.push({ x: x + width, y });
            pockets.push({ x, y: y + height });
            pockets.push({ x: x + width / 2, y: y + height });
            pockets.push({ x: x + width, y: y + height });
        }

        function initBalls() {
            balls.length = 0;

            // Cue ball
            balls.push(makeBall(
                TABLE.x + TABLE.width * 0.25,
                TABLE.y + TABLE.height / 2,
                '#ffffff',
                0,
                'cue'
            ));

            // Approximate standard pool colors for 1–8
            const colors = {
                1: '#f9d400',  // yellow
                2: '#1f6df2',  // blue
                3: '#f24b3b',  // red
                4: '#8741c1',  // purple
                5: '#f28b19',  // orange
                6: '#2f9b45',  // green
                7: '#8b1b3f',  // maroon
                8: '#000000'   // black
            };

            const startX = TABLE.x + TABLE.width * 0.65;
            const startY = TABLE.y + TABLE.height / 2;
            const rowSpacing = BALL_RADIUS * 2.1;
            const colSpacing = BALL_RADIUS * 2.1;

            let num = 1;
            for (let row = 0; row < 5; row++) {
                for (let i = 0; i <= row; i++) {
                    if (num > 15) break;
                    const x = startX + row * colSpacing;
                    const y = startY - row * BALL_RADIUS + i * (BALL_RADIUS * 2);

                    let number = num;
                    let type = 'solid';
                    let baseColor;
                    if (number === 8) {
                        type = 'eight';
                        baseColor = colors[8];
                    } else if (number >= 1 && number <= 7) {
                        type = 'solid';
                        baseColor = colors[number];
                    } else {
                        type = 'stripe';
                        const solidNumber = number - 8;
                        baseColor = colors[solidNumber];
                    }

                    balls.push(makeBall(x, y, baseColor, number, type));
                    num++;
                }
            }
        }

        function drawTable() {
            ctx.fillStyle = '#111319';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = TABLE.railColor;
            ctx.fillRect(TABLE.x - 25, TABLE.y - 25,
                TABLE.width + 50, TABLE.height + 50);

            ctx.fillStyle = TABLE.clothColor;
            ctx.fillRect(TABLE.x, TABLE.y, TABLE.width, TABLE.height);

            ctx.fillStyle = '#000000';
            for (const p of pockets) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, POCKET_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawBalls() {
            for (const b of balls) {
                if (!b.inPlay) continue;

                ctx.save();
                ctx.beginPath();
                ctx.arc(b.x, b.y, BALL_RADIUS, 0, Math.PI * 2);
                ctx.clip();

                if (b.type === 'solid' || b.type === 'eight' || b.type === 'cue') {
                    ctx.fillStyle = b.color;
                    ctx.fillRect(b.x - BALL_RADIUS, b.y - BALL_RADIUS,
                        BALL_RADIUS * 2, BALL_RADIUS * 2);
                } else if (b.type === 'stripe') {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(b.x - BALL_RADIUS, b.y - BALL_RADIUS,
                        BALL_RADIUS * 2, BALL_RADIUS * 2);

                    ctx.fillStyle = b.color;
                    const bandHeight = BALL_RADIUS * 1.2;
                    ctx.fillRect(
                        b.x - BALL_RADIUS,
                        b.y - bandHeight / 2,
                        BALL_RADIUS * 2,
                        bandHeight
                    );
                }

                if (b.type === 'cue') {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(b.x - BALL_RADIUS, b.y - BALL_RADIUS,
                        BALL_RADIUS * 2, BALL_RADIUS * 2);
                }

                ctx.restore();

                if (b.number !== 0) {
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, BALL_RADIUS * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = '#ffffff';
                    ctx.fill();

                    ctx.fillStyle = '#000000';
                    ctx.font = '10px system-ui';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(String(b.number), b.x, b.y + 0.5);
                }
            }
        }

        function updatePhysics() {
            for (const b of balls) {
                if (!b.inPlay) continue;

                b.x += b.vx;
                b.y += b.vy;

                // Compute current speed
                let speed = Math.hypot(b.vx, b.vy);

                // Apply a small linear drag to simulate rolling friction
                if (speed > 0) {
                    // reduce speed by a fixed amount each frame
                    speed = Math.max(0, speed - ROLL_DRAG);

                    // keep direction, just scale magnitude
                    const ux = b.vx / (Math.hypot(b.vx, b.vy) || 1);
                    const uy = b.vy / (Math.hypot(b.vx, b.vy) || 1);

                    b.vx = ux * speed;
                    b.vy = uy * speed;
                }

                // very small multiplier to smooth out any numerical noise
                b.vx *= FRICTION;
                b.vy *= FRICTION;

                // stop completely when very slow
                if (Math.hypot(b.vx, b.vy) < MIN_SPEED) {
                    b.vx = 0;
                    b.vy = 0;
                }


                const left = TABLE.x + BALL_RADIUS;
                const right = TABLE.x + TABLE.width - BALL_RADIUS;
                const top = TABLE.y + BALL_RADIUS;
                const bottom = TABLE.y + TABLE.height - BALL_RADIUS;

                if (b.x < left) { b.x = left; b.vx = -b.vx; }
                if (b.x > right) { b.x = right; b.vx = -b.vx; }
                if (b.y < top) { b.y = top; b.vy = -b.vy; }
                if (b.y > bottom) { b.y = bottom; b.vy = -b.vy; }
            }

            // Ball–ball collisions
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const a = balls[i];
                    const b = balls[j];
                    if (!a.inPlay || !b.inPlay) continue;

                    const dx = b.x - a.x;
                    const dy = b.y - a.y;
                    const dist = Math.hypot(dx, dy);
                    const minDist = BALL_RADIUS * 2;

                    if (dist > 0 && dist < minDist) {
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const overlap = (minDist - dist) / 2;

                        a.x -= nx * overlap;
                        a.y -= ny * overlap;
                        b.x += nx * overlap;
                        b.y += ny * overlap;

                        const av = a.vx * nx + a.vy * ny;
                        const bv = b.vx * nx + b.vy * ny;
                        const p = (2 * (av - bv)) / 2;
                        a.vx -= p * nx;
                        a.vy -= p * ny;
                        b.vx += p * nx;
                        b.vy += p * ny;
                    }
                }
            }

            // Pocket attraction: gently steer slow balls toward nearby pockets
            for (const b of balls) {
                if (!b.inPlay) continue;

                const speed = Math.hypot(b.vx, b.vy);
                if (speed === 0 || speed > POCKET_ATTRACT_MAX_SPEED) continue;

                for (const p of pockets) {
                    const dx = p.x - b.x;
                    const dy = p.y - b.y;
                    const dist = Math.hypot(dx, dy);

                    // Within an attraction ring just outside the pocket
                    if (dist > POCKET_RADIUS && dist < POCKET_ATTRACT_RADIUS) {
                        const ux = dx / (dist || 1);
                        const uy = dy / (dist || 1);

                        // Scale pull by how close the ball is: stronger near the pocket
                        const t = 1 - (dist - POCKET_RADIUS) /
                            (POCKET_ATTRACT_RADIUS - POCKET_RADIUS); // 0..1
                        const pull = POCKET_ATTRACT_STRENGTH * t;

                        b.vx += ux * pull;
                        b.vy += uy * pull;
                    }
                }
            }


            // Pockets + scratch
            for (const b of balls) {
                if (!b.inPlay) continue;
                for (const p of pockets) {
                    const d = Math.hypot(b.x - p.x, b.y - p.y);
                    if (d < POCKET_RADIUS - 3.6) {
                        if (b.type === 'cue') {
                            ballInHand = true;
                            placingCue = true;
                            b.inPlay = false;
                            b.vx = 0;
                            b.vy = 0;
                            document.getElementById('statusText').textContent =
                                'Scratch! Click anywhere on the table to place the cue ball.';
                        } else {
                            b.inPlay = false;
                            b.vx = 0;
                            b.vy = 0;
                        }
                        break;
                    }
                }
            }
        }

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left) * (canvas.width / rect.width),
                y: (evt.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        function cueBall() {
            return balls[0];
        }

        function ballsMoving() {
            return balls.some(b => Math.abs(b.vx) > 0 || Math.abs(b.vy) > 0);
        }

        // Power bar HUD: color from green -> red as power increases
        function updatePowerHUD() {
            powerValueEl.textContent = currentPower.toString();

            const t = (currentPower - MIN_POWER) / (MAX_POWER - MIN_POWER); // 0..1
            const r = Math.round(0 + (255 - 0) * t);
            const g = Math.round(200 - (200 - 0) * t);
            const b = 0;
            const color = `rgb(${r}, ${g}, ${b})`;

            powerBarFillEl.style.width = `${(currentPower / MAX_POWER) * 100}%`;
            powerBarFillEl.style.backgroundColor = color;

            modeLabelEl.textContent = useKeyboardPower ? '(Keyboard)' : '(Mouse)';
        }

        function shootWithPower(directionX, directionY) {
            const c = cueBall();
            const len = Math.hypot(directionX, directionY) || 1;
            const ux = directionX / len;
            const uy = directionY / len;

            // Map currentPower (1–14) to a softer, curved scale
            const t = (currentPower - MIN_POWER) / (MAX_POWER - MIN_POWER); // 0..1
            // Quadratic curve: very soft at low power, ramps up near the top
            const curved = t * t * t * t * t;  // try t*t or t*0.5 + t*t*0.5, etc.

            // Choose a max speed that feels right (play with 300–600)
            const MAX_SHOT_SPEED = 100;

            // Final speed along the aim direction
            const shotSpeed = 50 + curved * (MAX_SHOT_SPEED - 50); // min 50, max ~450

            c.vx = ux * shotSpeed;
            c.vy = uy * shotSpeed;

            document.getElementById('statusText').textContent = 'Shot!';
        }

        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);

            if (ballInHand && placingCue) {
                const c = cueBall();

                const left = TABLE.x + BALL_RADIUS;
                const right = TABLE.x + TABLE.width - BALL_RADIUS;
                const top = TABLE.y + BALL_RADIUS;
                const bottom = TABLE.y + TABLE.height - BALL_RADIUS;

                if (pos.x >= left && pos.x <= right && pos.y >= top && pos.y <= bottom) {
                    c.x = pos.x;
                    c.y = pos.y;
                    c.vx = 0;
                    c.vy = 0;
                    c.inPlay = true;
                    ballInHand = false;
                    placingCue = false;
                    document.getElementById('statusText').textContent =
                        'Cue placed. Drag from the cue ball to shoot.';
                }
                return;
            }

            if (ballsMoving()) return;
            const c = cueBall();
            const d = Math.hypot(pos.x - c.x, pos.y - c.y);
            if (d <= BALL_RADIUS + 5) {
                isDragging = true;
                dragPos = pos;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            hoverPos = pos;  // track mouse on the board for keyboard aim

            if (!isDragging) return;
            dragPos = pos;

            // Update power from drag distance (mouse mode only)
            if (!useKeyboardPower) {
                const c = cueBall();
                const dx = c.x - dragPos.x;
                const dy = c.y - dragPos.y;
                const dist = Math.hypot(dx, dy);
                const clamped = Math.min(dist, 400); // max at 400px
                const t = clamped / 300;       // 0..1
                const curvedT = Math.sqrt(t);  // makes low distances map to even lower t
                const scaled = MIN_POWER + curvedT * (MAX_POWER - MIN_POWER);
                currentPower = Math.max(MIN_POWER, Math.min(MAX_POWER, Math.round(scaled)));

                updatePowerHUD();
            }
        });

        canvas.addEventListener('mouseleave', () => {
            hoverPos = null;
        });

        canvas.addEventListener('mouseup', () => {
            if (!isDragging || !dragPos) return;

            // In keyboard mode, mouse drag is for aiming only, not shooting
            if (useKeyboardPower) {
                isDragging = false;
                dragPos = null;
                return;
            }

            isDragging = false;

            const c = cueBall();
            const dx = c.x - dragPos.x;
            const dy = c.y - dragPos.y;

            shootWithPower(dx, dy);

            dragPos = null;
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyK') {
                useKeyboardPower = !useKeyboardPower;
                document.getElementById('statusText').textContent =
                    useKeyboardPower
                        ? 'Keyboard mode: ↑/↓ set power, Space to shoot.'
                        : 'Mouse mode: Drag from cue ball to shoot.';
                updatePowerHUD();
                return;
            }

            if (!useKeyboardPower) return;

            if (e.code === 'ArrowUp') {
                currentPower = Math.min(MAX_POWER, currentPower + 1);
                updatePowerHUD();
            } else if (e.code === 'ArrowDown') {
                currentPower = Math.max(MIN_POWER, currentPower - 1);
                updatePowerHUD();
            } else if (e.code === 'Space') {
                if (ballsMoving() || ballInHand || placingCue) return;
                const c = cueBall();
                if (!c.inPlay) return;

                // Use hoverPos as aim direction when in keyboard mode
                let aimDx = 1;
                let aimDy = 0;
                if (hoverPos) {
                    aimDx = c.x - hoverPos.x;
                    aimDy = c.y - hoverPos.y;
                }

                shootWithPower(aimDx, aimDy);
            }
        });

        // Aim line HUD (mouse drag or keyboard + hover)
        function drawAimLine() {
            const c = cueBall();
            if (!c.inPlay) return;

            // If dragging, use dragPos; otherwise, in keyboard mode use hoverPos
            let target = null;
            if (isDragging && dragPos) {
                target = dragPos;
            } else if (useKeyboardPower && hoverPos) {
                target = hoverPos;
            }

            if (!target) return;

            const dx = c.x - target.x;
            const dy = c.y - target.y;
            const len = Math.hypot(dx, dy) || 1;
            const ux = dx / len;
            const uy = dy / len;

            const maxDist = 2000;
            let endX = c.x + ux * maxDist;
            let endY = c.y + uy * maxDist;

            const left = TABLE.x + BALL_RADIUS;
            const right = TABLE.x + TABLE.width - BALL_RADIUS;
            const top = TABLE.y + BALL_RADIUS;
            const bottom = TABLE.y + TABLE.height - BALL_RADIUS;

            if (ux < 0) {
                const t = (left - c.x) / ux;
                if (t > 0 && t < maxDist) {
                    endX = c.x + ux * t;
                    endY = c.y + uy * t;
                }
            } else if (ux > 0) {
                const t = (right - c.x) / ux;
                if (t > 0 && t < maxDist) {
                    endX = c.x + ux * t;
                    endY = c.y + uy * t;
                }
            }

            const currentDist = Math.hypot(endX - c.x, endY - c.y);
            if (uy < 0) {
                const t = (top - c.y) / uy;
                if (t > 0 && t < maxDist && t < currentDist) {
                    endX = c.x + ux * t;
                    endY = c.y + uy * t;
                }
            } else if (uy > 0) {
                const t = (bottom - c.y) / uy;
                if (t > 0 && t < maxDist && t < currentDist) {
                    endX = c.x + ux * t;
                    endY = c.y + uy * t;
                }
            }

            ctx.save();
            ctx.strokeStyle = 'rgba(255,255,255,0.7)';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 4]);
            ctx.beginPath();
            ctx.moveTo(c.x, c.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.restore();
        }

        function loop() {
            updatePhysics();
            drawTable();
            drawBalls();
            drawAimLine();
            requestAnimationFrame(loop);
        }

        initPockets();
        initBalls();
        updatePowerHUD();
        loop();
    </script>

</body>

</html>